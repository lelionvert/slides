<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>reveal-md</title>
    <link rel="stylesheet" href="./css/reveal.css" />
    <link rel="stylesheet" href="./css/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />
    <link rel="stylesheet" href="./css/print/paper.css" type="text/css" media="print" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template"># Quickie Map / Filter / Reduce
</script></section><section  data-markdown><script type="text/template">
## PrÃ©requis

- Function
  - lambda / arrow function notation
  - First Citizen
    - Callback
    - Return Function
  - Pure Function ?
- ImmutabilitÃ© ?
- Curry ?
</script></section><section ><section data-markdown><script type="text/template">
## Map
</script></section><section data-markdown><script type="text/template">
### Exemple

Faire du popcorn

[ğŸŒ½, ğŸŒ½, ğŸŒ½] => [ğŸ¿, ğŸ¿, ğŸ¿]

<aside class="notes"><p>par exemple, j&#39;ai un conteneur avec des Ã©pis de maÃ¯s que je voudrais transformer en pop corn</p>
</aside></script></section><section data-markdown><script type="text/template">
### DÃ©finition

**`map`** permet de **transformer** un _ensemble de donnÃ©es_ dans un **autre _ensemble de donnÃ©es_** de **mÃªme taille** <!-- .element: class="fragment" data-fragment-index="1" -->

**`map`** permet d'appliquer une **transformation** Ã  chaque Ã©lÃ©ments d'un _ensemble de donnÃ©es_, rÃ©sultant Ã  un **autre _ensemble de donnÃ©es_** de **mÃªme taille** <!-- .element: class="fragment" data-fragment-index="1" -->

<aside class="notes"><p>est-ce que quelqu&#39;un peut essayer de donner une dÃ©finition Ã  la fonction map ?
    reviewer : choisir une dÃ©finition</p>
</aside></script></section><section data-markdown><script type="text/template">
### Fonction de transformation / Mapper
</script></section><section data-markdown><script type="text/template">
#### Exemple

Chauffer

(ğŸŒ½) => ğŸ¿

<aside class="notes"><p>pour reprendre l&#39;exemple, pour transformer du maÃ¯s en pop corn, il suffit d&#39;avoir quelque chose permettant de le chauffer</p>
</aside></script></section><section data-markdown><script type="text/template">
#### DÃ©finition

Une **fonction** permet de **transformer** une **donnÃ©e** dans un **autre type de donnÃ©e** <!-- .element: class="fragment" data-fragment-index="1" -->

<aside class="notes"><p>est-ce que quelqu&#39;un peut essayer de donner une dÃ©finition Ã  un mapper ?
    reviewer : est-ce que &quot;Mapper&quot; c&#39;est le bon terme ?</p>
</aside></script></section><section data-markdown><script type="text/template">
### DÃ©mo

```typescript
const chauffer = (Ã©piDeMaÃ¯s) => "ğŸ¿"

const conteneurDÃ‰pisDeMaÃ¯s = ["ğŸŒ½", "ğŸŒ½", "ğŸŒ½"]

const conteneurDePopCorn = conteneurDÃ‰pisDeMaÃ¯s.map(chauffer)

expect(conteneurDePopCorn).toEqual(["ğŸ¿", "ğŸ¿", "ğŸ¿"])
expect(conteneurDÃ‰pisDeMaÃ¯s).toEqual(["ğŸŒ½", "ğŸŒ½", "ğŸŒ½"])
```

<aside class="notes"><p>map renvoit un nouveau tableau et ne change pas celui sur lequel la transformation est appliquÃ©e comme le montre les <code>expect</code></p>
</aside></script></section><section data-markdown><script type="text/template">
### Exemple

Mettre 2 Ã  la puissance `n` une suite de nombres

[`number`, `number`, `number`] => [`number`, `number`, `number`]

<aside class="notes"><p>nouvel exemple, cette fois-ci plus concret : avec des nombres
    on peut voir que le type de sorti PEUT etre le meme que le type d&#39;entrÃ©</p>
</aside></script></section><section data-markdown><script type="text/template">
### DÃ©mo

```typescript
const power2 = (someNumber) => 2 ** someNumber

const numbers = [1, 2, 3]

const numbersPowered = numbers.map(power2)

expect(numbersPowered).toEqual([2, 4, 8])
expect(numbers).toEqual([1, 2, 3])
```
</script></section></section><section ><section data-markdown><script type="text/template">
## Filtre / Filter
</script></section><section data-markdown><script type="text/template">
### Exemple

[ğŸ’, ğŸ…, ğŸ, ğŸ…, ğŸ] => [ğŸ…, ğŸ…]

<aside class="notes"><p>je voudrais rÃ©cupÃ©rer toutes les tomates qui sont dans mon bac Ã  fruits</p>
</aside></script></section><section data-markdown><script type="text/template">
### DÃ©finition

**`filter`** permet de **sÃ©lectionner** (filtrer) un **sous-_ensemble de donnÃ©es_** parmit un _ensemble de donnÃ©es_ <!-- .element: class="fragment" data-fragment-index="1" -->

<aside class="notes"><p>est-ce que quelqu&#39;un peut essayer de donner une dÃ©finition Ã  la fonction filter ?</p>
</aside></script></section><section data-markdown><script type="text/template">
### PrÃ©dicat / Predicate
</script></section><section data-markdown><script type="text/template">
#### Exemple

Est-ce que ce fruit est une tomate ?

(ğŸ’|ğŸ…|ğŸ) => `boolean`
</script></section><section data-markdown><script type="text/template">
#### DÃ©finition

Un **prÃ©dicat** est une **fonction** qui **vÃ©rifie** une **condition** <!-- .element: class="fragment" data-fragment-index="1" -->

<aside class="notes"><p>est-ce que quelqu&#39;un peut essayer de donner une dÃ©finition Ã  un prÃ©dicat ?</p>
</aside></script></section><section data-markdown><script type="text/template">
### DÃ©mo

```typescript
const estCeUneTomate = (fruit) => fruit === "ğŸ…"

const conteneurDeFruits = ["ğŸ’", "ğŸ…", "ğŸ", "ğŸ…", "ğŸ"]

const conteneurDeTomate = conteneurDeFruits.filter(estCeUneTomate)

expect(conteneurDeTomate).toEqual(["ğŸ…", "ğŸ…"])
expect(conteneurDeFruits).toEqual(["ğŸ’", "ğŸ…", "ğŸ", "ğŸ…", "ğŸ"])
```

<aside class="notes"><p>filter renvoit un nouveau tableau et ne change pas celui sur lequel le filter est appliquÃ© comme le montre les <code>expect</code></p>
</aside></script></section><section data-markdown><script type="text/template">
### Exemple

Filtrer les nombres pairs d'une suite de nombres

[`number`, `number`, `number`, `number`, `number`, `number`] => [`number`, `number`, `number`]
</script></section><section data-markdown><script type="text/template">
### DÃ©mo

```typescript
const isEven = (someNumber) => someNumber % 2 === 0

const numbers = [1, 2, 3, 4, 5, 6]

const evenNumbers = numbers.filter(isEven)

expect(evenNumbers).toEqual([2, 4, 6])
```
</script></section></section><section ><section data-markdown><script type="text/template">
## Reduce
</script></section><section data-markdown><script type="text/template">
### Exemple

Assembler une salade

[ğŸ…, ğŸ, ğŸ¥¬] => ğŸ¥—
</script></section><section data-markdown><script type="text/template">
### DÃ©finition

`reduce` permet de **rÃ©duire** (transformer) un _ensemble de donnÃ©es_ en une **autre donnÃ©e** <!-- .element: class="fragment" data-fragment-index="1" -->

<aside class="notes"><p>est-ce que quelqu&#39;un peut essayer de donner une dÃ©finition Ã  la fonction reduce ?</p>
</aside></script></section><section data-markdown><script type="text/template">
### Fonction de rÃ©duction / Reducer
</script></section><section data-markdown><script type="text/template">
#### Exemple

(ğŸ¥—, ğŸ¥¬) => ğŸ¥—
</script></section><section data-markdown><script type="text/template">
#### DÃ©finition

Un **reducer** est une **fonction** prend un **accumulateur** et un **Ã©lÃ©ment** et retourne un **accumulateur** <!-- .element: class="fragment" data-fragment-index="1" -->

<aside class="notes"><p>est-ce que quelqu&#39;un peut essayer de donner une dÃ©finition Ã  un reducer ?</p>
</aside></script></section><section data-markdown><script type="text/template">
### DÃ©mo

```typescript
const assembler = (salade, ingrÃ©dient) => "ğŸ¥—"

const ingrÃ©dients = ["ğŸ…", "ğŸ", "ğŸ¥¬"]

const salade = ingrÃ©dients.reduce(assembler, "ğŸ¥£")

expect(salade).toEqual("ğŸ¥—")
expect(ingrÃ©dients).toEqual(["ğŸ…", "ğŸ", "ğŸ¥¬"])
```

<aside class="notes"><p>pour commencer la salade, il faut d&#39;abord avoir un bol vide qui se remplira un peu plus Ã  chaque itÃ©ration</p>
</aside></script></section><section data-markdown><script type="text/template">
### Exemple

Faire le produit d'une suite de nombres

[`number`, `number`, `number`] => `number`

`number * number * number === number`
</script></section><section data-markdown><script type="text/template">
### DÃ©mo

```typescript
const multiply = (accumulator, item) => accumulator * item

const numbers = [2, 3, 4]

const product = numbers.reduce(multiply, 1)

expect(product).toEqual(24)
```

<!-- markdownlint-disable MD033 -->
<div class="fragment" data-fragment-index="1">

|                             accumulator | item |                                  result |
|----------------------------------------:|-----:|----------------------------------------:|
|                                       1 |    2 |     <span style="color: green">2</span> |
|     <span style="color: green">2</span> |    3 | <span style="color: royalblue">6</span> |
| <span style="color: royalblue">6</span> |    4 |                                      24 |

</div>
<!-- markdownlint-enable MD033 -->

<aside class="notes"><p>le rÃ©sultat du reducer est utilisÃ© en tant qu&#39;accumulateur pour l&#39;iteration suivante
    c&#39;est pour cette raison que nous sommes obligÃ© de fournir une valeur initiale : pour la premiÃ¨re itÃ©ration</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Tout en meme

Il possible de chainer les traitements sur les _ensembles de donnÃ©es_
</script></section><section data-markdown><script type="text/template">
### Exemple de la salade composÃ©e

Faire une salade avec ce qu'il y a dans mon frigo

[ğŸ…, ğŸ¥”, ğŸ, ğŸ…, ğŸ¥”, ğŸ, ğŸ¥¬] => ğŸ¥—
</script></section><section data-markdown><script type="text/template">
### DÃ©mo

```typescript
const estCeUnePommeDeTerre = (ingrÃ©dient) => ingrÃ©dient === "ğŸ¥”"
const inverser = (prÃ©dicat) => (Ã©lÃ©ment) => !prÃ©dicat(Ã©lÃ©ment)
const cuire = (ingrÃ©dient) => `${ingrÃ©dient} cuit`
const couper = (ingrÃ©dient) => `${ingrÃ©dient} coupÃ©`
const assembler = (salade, ingrÃ©dient) => "ğŸ¥—"

const ingrÃ©dients = ["ğŸ…", "ğŸ¥”", "ğŸ", "ğŸ…", "ğŸ¥”", "ğŸ", "ğŸ¥¬"]

const ingrÃ©dientsCuits = ingrÃ©dients.filter(estCeUnePommeDeTerre).map(cuire)
const ingrÃ©dientsCrus = ingrÃ©dients.filter(inverser(estCeUnePommeDeTerre))

const ingrÃ©dientsÃ€Couper = [
	...ingrÃ©dientsCrus,
	...ingrÃ©dientsCuits,
]

const ingrÃ©dientCoupÃ©s = ingrÃ©dientsÃ€Couper.map(couper)

const salade = ingrÃ©dientCoupÃ©s.reduce(assembler, "ğŸ¥£")

expect(salade).toEqual("ğŸ¥—")
```

<aside class="notes"><p>les pommes de terre crues sont toxiques pour l&#39;humain, il faut d&#39;abord les cuire pour les mettre dans la salade
    un prÃ©dicat renvoit toujours un <code>boolean</code> donc on peut inverser un prÃ©dicat en inversant la valeur de retour
    <code>filter</code> renvoit un tableau, donc on peut chainer le <code>map</code></p>
</aside></script></section></section><section  data-markdown><script type="text/template">
## RÃ©fÃ©rences

[filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)

[map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)

[reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
</script></section></div>
    </div>

    <script src="./js/reveal.js"></script>

    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // Optional libraries used to extend on reveal.js
      var deps = [
        { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: './plugin/zoom-js/zoom.js', async: true },
        { src: './plugin/notes/notes.js', async: true },
        { src: './plugin/math/math.js', async: true }
      ];

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        dependencies: deps
      };

      // options from URL query string
      var queryOptions = Reveal.getQueryHash() || {};

      var options = extend(defaultOptions, {}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
